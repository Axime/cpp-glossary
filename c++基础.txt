#include - (VC在自动生成程序时，会加一条#include "stdafx.h"，它已包含了包括window.h在内的多个头文件，其中就有string.h!!)
#using namespace std;

void
unsigned
int
short
double
float
bool
char(给单字符赋值要用单引号或数字)
int arr[?]: 数组，本质是N个连续的内存单元，并指向第0号元素的指针pAY，pAY+1是第1号指针，以此类推..(AY = pAY或&AY = &AY[0]，都代表数组第0号元素指针。相邻指针间的差值是该类型元素的size，如int为4，double为8)
char arr[?]: 字符数组，每个都会生成一个唯一地址(比较指针永远不会相等..)。其最后一个元素是'/0'(char p[3] = "AA"，留一个给'/0'，一旦数目越界则提示出错)。p = &p[0] = "AA"，只有&p才输出指针
char* arr: 字符指针，可引用char arr[?]，指向字符数组。也可直接赋值字符串(此时称作字符串常量)，字符串内容相同的字符串常量，则拥有相同的指针地址。

PS. char*的偏移值:
char* pChar1 = "abcd"，此时pChar1的指针地址0x00f38b34
char* pChar2 = char + 2，pChar2字符串内容为"cd"，指针地址0x00f38b36

特别注意!!!!!
1. char const *p: 指针p指向的那段内存中的数据不能变化，指针p的值可以改变
2. char* const p: 指针p的值不能变化
3. char* cPtrArr[]: char指针数组，关键地方在于 - 该指针指向的是字符数组还是字符串常量，性质完全不同。
4. char** cPtrPtr: 二级字符指针，例如: new char*[10]



//--------------------------------------------------------
// 系统函数:
//--------------------------------------------------------
int sizeof(a): 查询对象内存大小
char typeid(a).name(): 查询对象类型名称
void* malloc(size): 申请指定大小的内存，返回对应指针(只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的..需要在其他地方初始化..)
void free(void*): 释放之前申请的内存

//--------------------------------------------------------
// 字符串:
//--------------------------------------------------------
int strlen(const char* p): 返回字符数组中字符个数，不包括'/0';
strcpy(char dst[?], char* src): 将源字符串拷贝到目标字符串里(dst长度不可小于src长度，否则报错)
int rand() / void srand(unsigned int seed): 获取一个伪随机数(输入seed值)
int sprintf(char* buffer, const_char* content, ..): 字符串格式化

//--------------------------------------------------------
// 时间:
//--------------------------------------------------------
time_t: a int, seconds from 1970+ until now..
tm: struct {int year; int month; int day..}
time_t time(NULL): current time_t
void localtime_s(tm* a, time_t* b): time_t -> tm
time_t mktime(tm* a): tm -> time_t

//--------------------------------------------------------
// 文件:
//--------------------------------------------------------
FILE* fopen(const char* path, const char* mode): 打开一个文件并分配指针地址和缓存区
size_t fread(void*_Buffer, size_t eleSize, size_t eleCount, FILE* _Stream): 读取文件数据
size_t fwrite(void* Buffer, size_t eleSize, size_t eleCount, FILE* _Stream): 写入文件数据
int fclose(FILE* Stream): 更新缓冲区数据到文件，释放文件指针和缓冲区。成功关闭返回0，错误返回-1。
int feof(FILE* Stream): 当前position是否为文件尾部
int fseek(FILE* Stream, long _Offset, int Origin): offset偏移值，Origin初始位置。返回0表示成功。
char* fgets(char* Buffer. int _MaxCount, FILE* _Stream): 读取字符串，直到\n结束(按行存取数据)
int fprintf(FILE* Stream char* _Format): 字符串格式化式写入文件。

(c++的编译是按顺序的，要用到的必须先声明，这也是包含h文件重要原因)



==================================================
main函数(只可有一个)
--------------------------------------------------
int main(): 简单模式
int main(int argc): 忽略...
int main(int argc, char** argv): 命令行模式，argc表示argv字符串参数个数，argv表示输入的字符串(第0号元素为当前正在执行的exe文件的路径)。



==================================================
程序内存分配:
--------------------------------------------------
程序代码区 - 存放函数体的二进制代码
全局数据区 - 全局变量和静态变量，程序结束时释放
字符常量区 - char*数据，程序结束时释放
堆区(heap) - 需要手动分配和释放，例如malloc或new产生的内存指针(若没有手动释放，程序结束时可能由os回收。注意它与数据结构中的堆是两回事，分配方式类似于链表)
栈区(stack) - 由系统自动分配和释放，例如函数的参数、局部变量(操作方式类似于数据结构中的栈)



==================================================
头文件(应用程序和函数库之间的bridge)
--------------------------------------------------
作用在于多个代码文件全局变量(函数)的重用，防止定义的冲突，对各个被调用函数给出一个描述，其本身不需要包含逻辑实现代码，只起描述性作用。只需按照头文件中的接口声明来调用相关函数或变量，链接器会从库中寻找相应实现代码。

h文件(头文件): 
只负责常量、变量、函数、类etc的声明!!不能被编译。(作用类似目录，注册名字)

cpp文件(实现文件):
负责所有的实现(定义)!!每个cpp文件会被编译，生成一个obj文件，所有obj文件链接起来就是可执行程序。

注: h和cpp具有同样的主文件名，对编译器来讲是没有什么意义的，编译器不会匹配二者的主文件名，只认#include等语句。(相当于把*.h文件里的东西复制到*.cpp文件的开头...所以，就算全部写在*.cpp文件里也是一样的!!)



==================================================
预处理(末尾不加分号)
--------------------------------------------------
在编译之前的处理，一般被用来使源代码在不同的执行环境中被方便的修改或编译。

源文件包含:
#include - 

宏定义:
#define - 用指定内容替换指定内容(只做替换，不做其他)，#define AA 1.0 / #define A(x,y) x*y
ps. 
1. 如果没有初始化值，此时代表没有值，如果用该宏参与运算，会报错。(这种情况多是为了兼容或是提供一个功能开关)
2. 宏代码最大缺点是容易出错，预编译时复制宏代码常常产生意外...

头文件保护:(一个编译单元包含的xxx.h和yyy.h可能都包含zzz.h，使用该方法可防止同一个h文件被多次导入到当前编译单元导致报错...与#pragma once作用类似)
  #ifndef __???__(名称任意)
  #define __???__
  ...
  #endif

#undef - 删除宏名
例如: #define S(a.b) a*b / #define Pi 3.14159
只替换整体标识符!!(如果是Pii就不替换)

条件编译:
 - #if -> #else -> #endif
 - #if -> #elif(else if) -> #else -> #endif
 - #ifdef(如果此前定义了该宏名) -> #else -> #endif
 - #ifndef(如果此前未定义该宏名) -> #else -> #endif

设定编译器状态:
#pragma

#pragma comment(lib, "xxx.lib") - 动态设定库，用该方法可用条件编译来链接库，用项目设置方式则无法实现此需求。



==================================================
指针 & 引用
--------------------------------------------------
值:  int  aa(分配一个地址且不变)
指针: int* pA(以&a形式获取，以*a形式调用地址上的对象。若前面加上const，该指针的指向地址和引用对象都不可更改，一般不会加..)
引用: int& rA(引用完全可被看作"另一个称呼的自己"。不可为空，必须有初始值，且不可改变 !!!!!)

- 引用被赋值时，只需要"a"，而不是"&a"(int& aaa = aa / int& aaa = *pA)
- (因为引用不存在指向NULL)使用引用的代码效率比使用指针的要高!!(类似optional的作用?)
- 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。

ps.
1. void*也称作泛型指针，也就是可以指向任何类型数据的指针
2. 传指针或传引用效率上高于传值(传值需要分配内存空间并复制值)



==================================================
函数指针(func 和 &func都表示指针，和数组一样..)
--------------------------------------------------
普通函数 / 全局函数: 具有全局指针
int (*pF)(int, int) = func 或 &func
n = pf(1, 1) 或 (*pF)(1, 1)

静态函数(类函数): 定义和调用上跟普通函数差不多，具有全局指针
int (*pF)(int, int) = A::func 或 &A::func
n = pF(1, 1) 或 (*pF)(1, 1)

成员函数: 与实例绑定，没有全局指针(此时叫做指向绑定函数的指针，指针值永远为1..)
int (A::*pF)(int, int) = &A::func (成员函数必须使用 &)

typedef int (A::*Listener)(int, int)
Listener listener_A = &A::func

n = (ref.*listener_A)(2, 2) 或 (ref.*pF)(2, 2)
n =  (*p.*listener_A)(2, 2) 或  (*p.*pF)(2, 2)
n =  (p->*listener_A)(2, 2) 或  (p->*pF)(2, 2)



==================================================
const
--------------------------------------------------
常量   - const type  constName
常引用 - const type& refName
常对象 - const 类名   instName
常数组 - const type  arrName[size]
常指针 - const type* pointerName

ps.
1. 使用const可提高运行效率
2. 常量函数是c++对常量的一个扩展，确保类的封装性(函数后面加上const就成了常量函数)
3. non-const引用不能绑定const值，而const引用则能绑定non-const值，因为const引用可增加安全性。

涉及到指针的const:
- 指向变量不变: const char* p1 / char const* p2 ---> const位于星号左侧，则const修饰指针所指向变量(内容)。
- 指针本身不变: char* const p3                  ---> const位于星号右侧，则const修饰指针本身。
- 两者都不变:   const char* const p4
ps. 左变量，右指针。

类相关:
- const成员函数不改变对象的成员变量(类名::func(形参) const)
- const成员函数只可调用类中的其他const成员函数
- const修饰的对象，该对象的任何非const成员函数都不能被调用，因为非const成员函数会有修改成员变量的可能

常量折叠 / 常量替换:
将const常量放在符号表中，而并不给其分配内存。编译器直接进行替换优化。(将const当做宏...?)



==================================================
Static(两种用法)
--------------------------------------------------
静态全局变量:(内部链接)
static int n;不导出该符号，外界不可调用

静态全局函数:(内部链接)
static void func();不导出该符号，外界不可调用

静态局部变量:(内部链接)
该变量的存储方式和全局变量一样，且不导出符号

静态类属性:
初始化(int A::n = 1),访问(a.n / A::n)

静态类函数:
初始化(void A::func() { }),访问(A.func / pA->func / A::func())



==================================================
extern
--------------------------------------------------
该符号在别的编译单元里定义，也就是要把这个符号放到未解决符号表里去。外部链接可在程序范围内调用(因为导出了符号)，但由各个编译单元导出的符号在程序范围内不可重名!!!!!

表示标识符虽然没有在本文件或本文件当前位置中定义，但它是在别的文件中或本文件其他位置定义的全局变量。
ps:
1. 全局变量默认就是外部链接，即其extern可省略。(非const变量默认为extern)
2. 当指定某变量为外部链接时，前面必须显式加上extern!!!!!



==================================================
默认连接属性:（可通过添加extern和static改变链接属性）
--------------------------------------------------
1. 对于函数和变量，默认外部链接
2. 对于const变量，默认内部链接



==================================================
extern "C"(按照c的方式编译，不进行重命名)
--------------------------------------------------
c++支持重载(为支持重载，引入了函数重命名机制)
例如int func(A a)，通常会被编译成func_A形式(定义和调用的地方都会重命名)
c不支持重载，不会对函数重命名，引入由c编写的库时，导致调用的地方(c++编译)和定义的地方(c编译)函数名不一致。
extern "C" { #include "some_c.h" } 就是告诉c++编译器，按照c的方式编译，不进行重命名。



==================================================
struct(结构) / enum(枚举) / union(联合)
--------------------------------------------------
struct:
与class具有相同功能，用法完全相同。唯一区别是，struct中默认为public权限。
// StructA s(不用显示调用构造方法也行，class不可!!!!!) 或 StructA s = {...}

enum:(enum A { a=1, b, c=5, d })
如果枚举没有初始化，则从第一个标识符开始依次赋值0, 1, 2...其后未赋值成员依次加1(b=2, d=6)

enum类型:(enum class A: uint64 {a, b, c}) / (enum class A {a, b, c})
是c++的一个基本类型，此种枚举为类型安全的，可指定所使用类型，默认类型为int。不能隐式转换为整数，也无法与整数做比较。
使用枚举名时，必须明确指定其所属范围，如A::a

union(成员变量共享内存):
和class相似，不支持继承，不能定义虚函数，默认为public权限。

ps.
1. typedef typename stree<T>::iterator iterator;加typename表明iterator是一种类型，不加typename表明iterator是stree<T>内的成员变量



==================================================
计算class和struct的size(嵌套结构体或数组要进行"展开")
--------------------------------------------------
1. 按前后顺序依次计算每个成员，遍历成员时，要将当前偏移量换算成当前成员(记得"展开")大小的公倍数
2. (最后)结构体大小必须是各个成员大小的整数倍(公倍数)。

// ps. 优化方式: size较小写在前，size较大写在后。



==================================================
new/delete关键字:(在c++中完全取代malloc/free功能。malloc只负责申请内存，不负责创建对象。new不仅申请内存，且构造对象)
--------------------------------------------------
NodeAA* nodeA = new NodeAA(xx, yy);
delete nodeA;

NodeAA* nodeA = new NodeAA[5];(new多个对象(数组)时，不能传参数，所以该类必须有默认构造函数。此时nodeA表示第0号元素指针，nodeA+1表示第1号元素指针..)
delete [] nodeA;



==================================================
类
--------------------------------------------------

构造方法:
Main() - 构造时，先调用父类，再调用子类(virtual A(){trace("A");}，B:public A {B(){A:: A();trace("B");}}，此时输出结果为: AAB)
ps. 不管子类是否定义构造方法，有无参数，都会首先执行父类无参数的构造方法，然后执行自己的构造方法。

初始化列表:
NodeAA::NodeAA(): m_x(0.0f), m_y(0.0f), m_rotation(0.0f)..{ }
ps. 用该方式可初始化const变量!!

子类执行父类带参数的构造方法:
B() : A(...params) { };需要用初始化类成员的方式!!
    例如:
    class A {
    public:
      A() {trace("A0")}
      A(int a) {trace("A1")}
    }
    class B: public A {
    public:
      B() {trace("B0")}
      B(int a):A(a) {trace("B1")}
    }
    此时A* a = new B(1);输出结果为: A1B1;
    
拷贝构造函数:
A(const A& a) { } - 很多情况下需要自定义拷贝构造函数，没有则由系统默认生成，A(const A&)或A(A&)，由编译器根据上下文选择。
满足条件 - 第一个参数是A&或const A&，且没有其他参数或其他参数都有默认值。
1. 以值传递的方式传入函数参数
2. 以值传递的方式从函数返回
3. 通过另一对象进行初始化，例如Node a(100);Node b = a或者Node b(a);
ps. 类中可同时存在2个以上拷贝构造函数，例如A(const A&)和A(A&)

函数执行return时的步骤:
1. 产生一个临时变量f，用于实际传出
2. 调用拷贝构造函数把result的值传给f
3. 析构result局部变量
4. 由函数返回f(外部未使用则析构)

析构方法:
~Main() - 析构时，先调用子类，再调用父类(virtual ~A(){trace("A");}，B:public A {~B(){A::~A();trace("B");}}，此时输出结果为: ABA)
ps. 需要复写的析构方法要加virtual，否则子类的析构方法无法调用，子类的析构函数里无需显式调用父类的析构函数!!

继承:
class B: public A { }
ps. 如果不加public，默认为private !!!!!(所有成员和方法都应标明public / private)

私有继承:
class B: private A { } 
基类所有成员在派生类中都变为派生类的private成员

类B重写并执行父类A的update方法(super):
void update() { A::update(); ... }



==================================================
虚函数:
--------------------------------------------------
只有实现虚函数才对其可进行复写
virtual void update() { } 

ps. 
1. 父类中方法声明为virtual，该方法在子类中自动就是virtual...!!
2. 除了构造函数外，其他函数都可能是虚函数



==================================================
纯虚函数、抽象类: 
--------------------------------------------------
只要有一个方法是纯虚函数，就是抽象类。

相当于接口，不能直接实例化
virtual void update() {} = 0



==================================================
override关键字:
--------------------------------------------------
如果subclass在虚函数声明时使用了override描述符，那么必须对其实现
例如: class B: public A {
  void test() override
}



==================================================
inline函数:(代码层面的静态链接..?没有Inline都是动态链接..?)
--------------------------------------------------
内联函数在编译过程中会被源代码替换，提高效率。(c语言没有，只能使用宏，用inline可替代c中表达式形式的宏定义)
inline void funcA( int n ) { ... }
ps.
1. inline必须与函数定义放在一起才有效，放在函数声明前不起任何作用
2. 调用内联函数时，内联函数必须定义在(.h文件)中，与通常的函数定义位置(.cpp文件)不一样
3. 在类中直接定义(.h文件)，不需要用inline修饰也会自动成为内联函数(不推荐)
4. 在类外(同在一个.h文件)函数定义前要加inline关键字(推荐)
5. inline对编译器只是一种建议，编译器在一些条件下会忽略(代码行数过长)



==================================================
运算符重载
--------------------------------------------------
A operator+( A a ) { }...a = a1 + a2;
A operator[]( char* c ) { }...a = a1[c];



==================================================
友元(严重的耦合....)
--------------------------------------------------
可访问类的私有成员。
ps.
1. 只能出现在类定义内部，一般放在类定义结尾。

友元函数:
可访问类私有成员的非成员函数，是定义在类外的普通函数，不属于任何类，属于全局函数。
class A {
  public:
    ...
    friend void funcA( A a );
}
ps.
1. 可放在类的私有部分，也可放在共有部分，没有区别。
2. 一个函数可以是多个类的友元函数，只需在各个类中分别声明。

友元类:
友元类的所有成员函数都是另一个类的友元函数，可以访问另一个类中的私有成员。
class A {
  public:
    ...
    friend class B;
}
ps.
1. 友元关系不能被继承。
2. 友元关系是单向的，A是B的友元，B不一定是A的友元。(只看类中是否有友元声明)



==================================================
命名空间
--------------------------------------------------
嵌套namespace: (本质就是给里面的每一个符号加上一个命名空间前缀)
namespace ns1 {
    namespace ns2 {
        int n;
    }
}
ps. 无论h文件还是cpp文件中的声明和定义，都使用namespace xxx { }

直接使用:
cout << ns1::ns2::n;

导入命名空间:
using namespace ns1::ns2;cout << n;

导入命名空间指定成员:
using ns1::ns2::n;cout << n;



==================================================
前置声明
--------------------------------------------------
传统做法，一旦有修改则会重新编译
#include "Date.h"
class Task {
  public:
    Date getData();
}

前置声明做法，即使Data.h发生改变，Task也不需要重新编译
class Date;
class Task { 
  public:
    Date getData();
}

ps.
1. 尽量用前置声明代替#include()!!条件是使用指针或引用!!
2. 前提: 无需了解类的大小或具体成员，如返回值或参数!!前置声明写在哪里都行，但一般写在h文件中的较前部分，cpp文件中涉及构造或成员调用等再包含相关的h文件!!
3. 只是告诉编译器这是一个类型，但无法告知类型的大小，成员等具体内容。而头文件包含全部内容。



==================================================
template(generic)
--------------------------------------------------
1. 模板在代入时才能检查语法是否正确(涉及到运算符重载....)
2. 通常定义在头文件里

类模板:
template<class/typename T, int len = 1024>
class A {
  // T为类型参数，len为非类型参数(可提高缺省实参)
}
例子:
// stack.h
template <class T, int LEN> class Stack {
  public:
    Stack();
    ~Stack();
    void push(T t);
    T pop();
    bool isEmpty();
  private:
    T *m_pt;
    int m_maxSize;
    int m_size;
};
# include "stack.cpp"
// stack.cpp
template<class T, int LEN>
Stack<T>::Stack() {
  m_maxSize = LEN;
  m_size = 0;
  m_pt = new T(m_maxSize);
}
template<class T, int LEN>
Stack<T>::~Stack() {
  delete [] m_pt;
}
...

方法模板:
一个类没有模板参数，但是成员函数有模板参数，是可行的。
class Util {
  public:
    template <class T> 
    static bool equal( T t1, T t2 ) {
      return t1 == t2;
    }
    template <class T> 
    bool equal( T t1, T t2 ) {
      return t1 == t2;
    }
};
int main() {
  Util util;
  int a = 1, b = 2;
  util.equal<int>(1, 2);
  Util::equal<int>(1, 2);
  return 0;
}

泛型限制:(类型特化)


















